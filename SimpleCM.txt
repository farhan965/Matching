USE [SalesStaging]
GO

/****** Object:  StoredProcedure [test].[LoadMatchingDataToStagingT3]    Script Date: 10/5/2024 1:06:28 PM ******/
SET ANSI_NULLS ON
GO

SET QUOTED_IDENTIFIER ON
GO





   ALTER PROCEDURE [test].[LoadMatchingDataToStagingT3]
(
    @SourceSchema NVARCHAR(128),
    @SourceTable NVARCHAR(128),
    @MappingSchema NVARCHAR(128),
    @MappingTable NVARCHAR(128)
)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @DynamicSQL NVARCHAR(MAX);
    DECLARE @ColumnNames NVARCHAR(MAX);
    DECLARE @EmailColumnName NVARCHAR(128);
    DECLARE @SourceTableName NVARCHAR(256) = QUOTENAME(@SourceSchema) + '.' + QUOTENAME(@SourceTable);
    DECLARE @MappingTableName NVARCHAR(256) = QUOTENAME(@MappingSchema) + '.' + QUOTENAME(@MappingTable);
    DECLARE @NewTableName NVARCHAR(256) = QUOTENAME(@SourceSchema) + '.' + QUOTENAME(@SourceTable + '_Temp');

    -- Step 1: Dynamically identify the correct email column from the source table
    
	IF @SourceSchema='test1'

	SELECT @EmailColumnName = NAME
    FROM SYS.COLUMNS 
    WHERE object_id = OBJECT_ID(@SourceTableName) 
    AND NAME IN ('FA Email', 'FA-PM Email');

    -- Check if an email column was found; if not, raise an error
    IF @EmailColumnName IS NULL
    BEGIN
        RAISERROR('No Email column found in the source table.', 16, 1);
        RETURN;
    END

    -- Step 2: Dynamically load all column names from the source table
    SELECT @ColumnNames = STRING_AGG('src.' + QUOTENAME(COLUMN_NAME), ', ')
    FROM INFORMATION_SCHEMA.COLUMNS
    WHERE TABLE_NAME = @SourceTable 
    AND TABLE_SCHEMA = @SourceSchema;

    -- For debugging: Print the dynamic SQL for column names
    PRINT 'Column Names: ' + @ColumnNames;

    -- Step 3: Create a CTE to perform the operations using the identified Email column
    SET @DynamicSQL = '
    WITH 
    CTE AS
    (
        SELECT ' + @ColumnNames + ',
            CASE 
                WHEN LOWER(src.' + QUOTENAME(@EmailColumnName) + ') IN (SELECT LOWER(map.New_Email) FROM ' + @MappingTableName + ')
                      THEN ''Y''
                ELSE ''N''
            END AS Status,
            CASE 
               WHEN LOWER(src.' + QUOTENAME(@EmailColumnName) + ') IN (SELECT LOWER(map.New_Email) FROM ' + @MappingTableName + ') 
                      THEN GETDATE()
                ELSE NULL
            END AS InsertDataTime,
            map.Id as ID
        FROM ' + @SourceTableName + ' AS src
        LEFT JOIN ' + @MappingTableName + ' AS map
        ON (LOWER(src.' + QUOTENAME(@EmailColumnName) + ') = LOWER(map.New_Email))
    )
        
    -- Step 4: Create the new table from the CTE
    SELECT * INTO ' + @NewTableName + ' FROM CTE;';

    -- Execute the dynamic SQL
    EXEC sp_executesql @DynamicSQL;

    -- For debugging: Print the dynamic SQL for table creation
    PRINT 'Dynamic SQL executed to create table: ' + @NewTableName;

END;

else if @SourceSchema='test2'
 WITH cte AS (
        SELECT DISTINCT Email AS New_Email 
        FROM ' + @MappingSchema + '.' + @MappingTable + '
        WHERE [RecordType.Developer] IN (''Ad'', ''Hid'', ''Hom'')
        
        UNION ALL
        
        SELECT DISTINCT Secondary_Email__c AS New_Email 
        FROM ' + @MappingSchema + '.' + @MappingTable + '
        WHERE [RecordType.Developer] IN  (''Ad'', ''Hid'', ''Hom'')
        
        
    ),
    cte2 AS (
         SELECT DISTINCT ID
        FROM ' + @MappingSchema + '.' + @MappingTable + '
        WHERE [RecordType.Developer] IN  (''Ad'', ''Hid'', ''Hom'')
    )

SELECT @EmailColumnName = NAME
    FROM SYS.COLUMNS 
    WHERE object_id = OBJECT_ID(@SourceTableName) 
    AND NAME IN ('FA Email', 'FA-PM Email');

SELECT @IDColumnName = NAME
    FROM SYS.COLUMNS 
    WHERE object_id = OBJECT_ID(@SourceTableName) 
    AND NAME IN ('ID', 'iD2');

    -- Check if an email column was found; if not, raise an error
    IF @EmailColumnName is not NULL
    BEGIN
         WITH 
    CTE AS
    (
        SELECT ' + @ColumnNames + ',
            CASE 
                WHEN LOWER(src.' + QUOTENAME(@EmailColumnName) + ') IN (SELECT LOWER(map.New_Email) FROM ' + cte1 + ')
                      THEN ''Y''
                ELSE ''N''
            END AS Status,
            CASE 
               WHEN LOWER(src.' + QUOTENAME(@EmailColumnName) + ') IN (SELECT LOWER(map.New_Email) FROM ' +cte1 ') 
                      THEN GETDATE()
                ELSE NULL
            END AS InsertDataTime
        FROM ' + @SourceTableName + ' AS src
        
    )
        
    -- Step 4: Create the new table from the CTE
    SELECT * INTO ' + @NewTableName + ' FROM CTE;';

    -- Execute the dynamic SQL
    EXEC sp_executesql @DynamicSQL;

    -- For debugging: Print the dynamic SQL for table creation
    PRINT 'Dynamic SQL executed to create table: ' + @NewTableName;
    END

	elseIF @IDColumnName is not NULL and @EmailColumnName is not null
    BEGIN
         WITH 
    CTE AS
    (
        SELECT ' + @ColumnNames + ',
            CASE 
                WHEN LOWER(src.' + QUOTENAME(@EmailColumnName) + ') IN (SELECT LOWER(map.New_Email) FROM ' + cte1 + ') or (src.' + QUOTENAME(@IDColumnName) + ') IN (SELECT ID FROM ' + cte2 + ') 
                      THEN ''Y''
                ELSE ''N''
            END AS Status,
            CASE 
               WHEN LOWER(src.' + QUOTENAME(@EmailColumnName) + ') IN (SELECT LOWER(map.New_Email) FROM ' +cte1 ')or (src.' + QUOTENAME(@IDColumnName) + ') IN (SELECT ID FROM ' + cte2 + ') 
                      THEN GETDATE()
                ELSE NULL
            END AS InsertDataTime
        FROM ' + @SourceTableName + ' AS src
        
    )

	- Step 4: Create the new table from the CTE
    SELECT * INTO ' + @NewTableName + ' FROM CTE;';

    -- Execute the dynamic SQL
    EXEC sp_executesql @DynamicSQL;

    -- For debugging: Print the dynamic SQL for table creation
    PRINT 'Dynamic SQL executed to create table: ' + @NewTableName;
    END

	 


GO


