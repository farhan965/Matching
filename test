


CREATE PROCEDURE [dbo].[LoadMatchingData]
(
    @SourceSchema NVARCHAR(128),
    @SourceTable NVARCHAR(128),
    @MappingSchema NVARCHAR(128),
    @MappingTable NVARCHAR(128),
    @StagingSchema NVARCHAR(128),
    @StagingTable NVARCHAR(128),
    @NonMatchingSchema NVARCHAR(128)
)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @DynamicSQL NVARCHAR(MAX);
    DECLARE @ColumnNames NVARCHAR(MAX);
    DECLARE @SourceTableName NVARCHAR(256) = QUOTENAME(@SourceSchema) + '.' + QUOTENAME(@SourceTable);
    DECLARE @MappingTableName NVARCHAR(256) = QUOTENAME(@MappingSchema) + '.' + QUOTENAME(@MappingTable);
    DECLARE @StagingTableName NVARCHAR(256) = QUOTENAME(@StagingSchema) + '.' + QUOTENAME(@StagingTable);
    DECLARE @NonMatchingTableName NVARCHAR(256) = QUOTENAME(@NonMatchingSchema) + '.' + QUOTENAME(@StagingTable);

    -- Step 1: Dynamically load column names from the source table
    SELECT @ColumnNames = STRING_AGG('src.' + QUOTENAME(COLUMN_NAME), ', ')
    FROM INFORMATION_SCHEMA.COLUMNS
    WHERE TABLE_NAME = @SourceTable 
    AND TABLE_SCHEMA = @SourceSchema;

    -- For debugging: Print the dynamic SQL for column names
    PRINT 'Column Names: ' + @ColumnNames;
	
	DECLARE @MatchingTB nvarchar(max) = QUOTENAME(@StagingTableName + '_OUTPUT_T')

    -- Step 2: Drop the Matching or staging and non-matching tables if they already exist
    SET @DynamicSQL = 'IF OBJECT_ID(''' + @MatchingTB + ''', ''U'') IS NOT NULL DROP TABLE ' + @MatchingTB + ';';
    -- For debugging: Print the dynamic SQL for dropping the existing matching table
	PRINT 'Dropping Existing  Matching Table:' +  @DynamicSQL;
	EXEC sp_executesql @DynamicSQL;
	
    
	
	DECLARE @NonMatchingTB nvarchar(max) = QUOTENAME(@NonMatchingTableName + '_OUTPUT_F')
	
    SET @DynamicSQL = 'IF OBJECT_ID(''' + @NonMatchingTB + ''', ''U'') IS NOT NULL DROP TABLE ' + @NonMatchingTB + ';';
    -- For debugging: Print the dynamic SQL for dropping the existing Non matching table
	PRINT 'Dropping Existing Non Matching Table:' + @DynamicSQL;
	EXEC sp_executesql @DynamicSQL;

    -- Step 3: Create the staging table dynamically with the same schema as the source table
    SET @DynamicSQL = 'SELECT ' + REPLACE(@ColumnNames, 'src.', '') + ' INTO ' + @MatchingTB + ' FROM ' + @SourceTableName + ' WHERE 1=0;';
    
    -- For debugging: Print the dynamic SQL for creating the staging table
    PRINT 'Create Staging Table SQL: ' + @DynamicSQL;
    
    EXEC sp_executesql @DynamicSQL;

    -- Step 4: Create the non-matching table dynamically with the same schema as the source table
    SET @DynamicSQL = 'SELECT ' + REPLACE(@ColumnNames, 'src.', '') + ' INTO ' + @NonMatchingTB + ' FROM ' + @SourceTableName + ' WHERE 1=0;';
    
    -- For debugging: Print the dynamic SQL for creating the non-matching table
    PRINT 'Create Non-Matching Table SQL: ' + @DynamicSQL;
    
    EXEC sp_executesql @DynamicSQL;

    -- Step 5: Insert matching records into the staging table
    SET @DynamicSQL = '
        INSERT INTO ' + @MatchingTB + ' (' + REPLACE(@ColumnNames, 'src.', '') + ')
        SELECT ' + @ColumnNames + '
        FROM ' + @SourceTableName + ' AS src' +  ' '+
		'WHERE LOWER(src.[Region]) in (select distinct LOWER(Region) from' + @MappingTableName + ');';

    -- For debugging: Print the dynamic SQL for inserting matching data
    PRINT 'Insert Matching Records SQL: ' + @DynamicSQL;

    EXEC sp_executesql @DynamicSQL;

    -- Step 6: Insert non-matching records into the non-matching table
    SET @DynamicSQL = '
        INSERT INTO ' + @NonMatchingTB + ' (' + REPLACE(@ColumnNames, 'src.', '') + ')
        SELECT ' + @ColumnNames + '
        FROM ' + @SourceTableName + ' AS src'+ ' '+
        + 'WHERE LOWER(src.[Region]) not in (select distinct LOWER(Region) from' + @MappingTableName +');';

    -- For debugging: Print the dynamic SQL for inserting non-matching data
    PRINT 'Insert Non-Matching Records SQL: ' + @DynamicSQL;

    EXEC sp_executesql @DynamicSQL;
END;


----PROC 2-----


CREATE PROCEDURE [dbo].[LoadMatchingDataToStaging]
(
    @SourceSchema NVARCHAR(128),
    @SourceTable NVARCHAR(128),
    @MappingSchema NVARCHAR(128),
    @MappingTable NVARCHAR(128),
    @StagingSchema NVARCHAR(128),
    @StagingTable NVARCHAR(128),
    @NonMatchingSchema NVARCHAR(128),
    @NonMatchingTable NVARCHAR(128)
)
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @DynamicSQL NVARCHAR(MAX);
    DECLARE @ColumnNames NVARCHAR(MAX);
    DECLARE @SourceTableName NVARCHAR(256) = QUOTENAME(@SourceSchema) + '.' + QUOTENAME(@SourceTable);
    DECLARE @MappingTableName NVARCHAR(256) = QUOTENAME(@MappingSchema) + '.' + QUOTENAME(@MappingTable);
    DECLARE @StagingTableName NVARCHAR(256) = QUOTENAME(@StagingSchema) + '.' + QUOTENAME(@StagingTable);
    DECLARE @NonMatchingTableName NVARCHAR(256) = QUOTENAME(@NonMatchingSchema) + '.' + QUOTENAME(@NonMatchingTable);

    -- Step 1: Dynamically load column names from the source table
    SELECT @ColumnNames = STRING_AGG('src.' + QUOTENAME(COLUMN_NAME), ', ')
    FROM INFORMATION_SCHEMA.COLUMNS
    WHERE TABLE_NAME = @SourceTable 
    AND TABLE_SCHEMA = @SourceSchema;

    -- Adding Mapping table 'Id' and a Current DateTime column to the staging table
    SET @ColumnNames = @ColumnNames + ', map.Id, GETDATE() AS LoadTimestamp';

    -- For debugging: Print the dynamic SQL for column names
    PRINT 'Column Names: ' + @ColumnNames;
	
    -- Step 2: Drop the Matching or staging and non-matching tables if they already exist
    SET @DynamicSQL = 'IF OBJECT_ID(''' + @StagingTableName + ''', ''U'') IS NOT NULL DROP TABLE ' + @StagingTableName + ';';
    -- For debugging: Print the dynamic SQL for dropping the existing matching table
    PRINT 'Dropping Existing Matching Table:' +  @DynamicSQL;
    EXEC sp_executesql @DynamicSQL;

    SET @DynamicSQL = 'IF OBJECT_ID(''' + @NonMatchingTableName + ''', ''U'') IS NOT NULL DROP TABLE ' + @NonMatchingTableName + ';';
    -- For debugging: Print the dynamic SQL for dropping the existing Non matching table
    PRINT 'Dropping Existing Non Matching Table:' + @DynamicSQL;
    EXEC sp_executesql @DynamicSQL;

    -- Step 3: Create the staging table dynamically with the same schema as the source table, including Id and LoadTimestamp
    SET @DynamicSQL = 'SELECT ' + REPLACE(@ColumnNames, 'src.', '') + ' INTO ' + @StagingTableName + ' FROM ' + @SourceTableName + ' WHERE 1=0;';
    
    -- For debugging: Print the dynamic SQL for creating the staging table
    PRINT 'Create Staging Table SQL: ' + @DynamicSQL;
    EXEC sp_executesql @DynamicSQL;

    -- Step 4: Create the non-matching table dynamically with the same schema as the source table
    SET @DynamicSQL = 'SELECT ' + REPLACE(@ColumnNames, 'src.', '') + ' INTO ' + @NonMatchingTableName + ' FROM ' + @SourceTableName + ' WHERE 1=0;';
    
    -- For debugging: Print the dynamic SQL for creating the non-matching table
    PRINT 'Create Non-Matching Table SQL: ' + @DynamicSQL;
    EXEC sp_executesql @DynamicSQL;

    -- Step 5: Insert matching records into the staging table
    SET @DynamicSQL = '
        INSERT INTO ' + @StagingTableName + ' (' + REPLACE(@ColumnNames, 'src.', '') + ')
        SELECT ' + @ColumnNames + '
        FROM ' + @SourceTableName + ' AS src
        INNER JOIN ' + @MappingTableName + ' AS map
        ON LOWER(src.[region]) = LOWER(map.region);';

    -- For debugging: Print the dynamic SQL for inserting matching data
    PRINT 'Insert Matching Records SQL: ' + @DynamicSQL;
    EXEC sp_executesql @DynamicSQL;

    -- Step 6: Insert non-matching records into the non-matching table (excluding Id and LoadTimestamp)
    SET @DynamicSQL = '
        INSERT INTO ' + @NonMatchingTableName + ' (' + REPLACE(@ColumnNames, ', map.Id, GETDATE() AS LoadTimestamp', '') + ')
        SELECT ' + REPLACE(@ColumnNames, ', map.Id, GETDATE() AS LoadTimestamp', '') + '
        FROM ' + @SourceTableName + ' AS src
        LEFT JOIN ' + @MappingTableName + ' AS map
        ON LOWER(src.[region]) = LOWER(map.region)
        WHERE map.Email IS NULL;';

    -- For debugging: Print the dynamic SQL for inserting non-matching data
    PRINT 'Insert Non-Matching Records SQL: ' + @DynamicSQL;
    EXEC sp_executesql @DynamicSQL;
END;







	

	
	
	
	

